no time to write up a document. Essentially, interfaces will be a special type of struct that contains only pointers. They should be used as a map on top of an inner value (almost definitely a struct) so that operations can use the members of the interface without caring which type they came from. Structs can define a transition to any given interface type as a function, allowing implicit conversion. They can act as a function vtable, but also as a view into scalar members for direct reads and writes.

Interfaces should usually be generated and discarded in one scope. The interface type itself should usually not be stored, only passed to deeper-nested functions. This is a convention, not a language restriction.

It is not safe to carry derived interfaces beyond the value they are initialized with. For example, storing an array of interfaces to game objects is tricky because you might reorder the memory space of the actual game objects but not the interfaces themselves. Plenty of room for dangling pointers. For safe polymorphism, it may be recommended to keep a pointer to your object paired with the function used for converting it to an interface. That way, interfaces are generated and discarded at one callsite. It is still possible to properly manage interfaces in-lifetime with their counterpart objects, so there is no restriction.
