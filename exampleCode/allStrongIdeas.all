// This document demonstrates how several language features compose together:
// - Functions as literal values
// - Function argument sugar: parameters accessed via %n, named params desugar to %0, %1, etc.
// - State-based methods: functions can take an implicit 'state' (like 'this'), accessed via .field
// - Composition via delegation: 'delegate' = 'route' (expose fields) + 'substitute' (type conversion)
// - Namespace resolution: creates types like namespace_statename (e.g., apple_instance)
// - Different reference types with clearer and more expressive syntax than C/C++
// Annotations generated by Claude AI after detailed explanation and clarified by me.

// Function with no declaration using parameter enumeration
// `sub` becomes a generic function which must be cast to a concrete one before use.
// cast can be done implicitly at the callsite, as long as the type and arity implied by the call can be mapped to this generic.
sub = ${return %0 - %1};
// This example uses implicit enumeration
// Each `%` desugars to the next `n`.
add = ${return % + %};

namespace apple {
    // Define a state type called 'instance'
    // Creates the type 'apple_instance' (namespace_statename convention)
    // States are like structs but can be bound to functions as implicit 'this'
    state instance;
    state instance {
        arr[32, char] name;
        int shine;
        int state instance (int param1) virtualMethod;
    };

    // Function with state 'instance' - takes apple_instance as implicit first param
    // Parameters: %0 = name (seq[32, char]), %1 = shine (int)
    // .name and .shine are sugar for this.name and this.shine
    void state instance(seq[32, char] name, int shine) init = ${
        .name = copy name;  // .name accesses state member, 'name' is %0 parameter
        .shine = shine;     // .shine is state member, 'shine' is %1 parameter
        .instance = ${
            .shine += param1;
            return .shine;
        };
    };

    // Function with state but no additional parameters
    // .name and .shine refer to the state's fields
    void state instance() print = ${
        printf("I am a %s apple and my shiny level is %d\n", .name, .shine);
    };
}

namespace greenApple {
    state instance {
        // 'delegate' = 'route' + 'substitute'
        // route: fields of inner are accessible as if they were ours (g.shine works)
        // substitute: we can be implicitly converted to apple_instance for function calls
        delegate apple_instance inner;
    } call init;

    // Initialization that delegates to the inner apple's init
    // .inner accesses our state member, then @init calls a method on it
    void state instance(int shine) init = ${
        .inner@init("Green", shine);
    };
    
    // Note: no print() defined here, will delegate to apple::print via 'inner'
}

main = ${
    // Declare an apple_instance (uninitialized, like C structs)
    apple_instance a;

    // @ operator: simply calls a function with the prior value as its first parameter
    // 5@add(1) works fine, because it's a simple desugar
    // If the lhs comes from any number of namespaces, `@` can search those namespaces automatically.
    // Looks for: void state apple_instance(...) init
    // Finds it in apple namespace
    a@init("Granny Smith", 100);
    a@print();
    // Virtual methods don't have a super-ergonomic sugar, and I kind of prefer it this way.
    // Virtual methods are handled explicitly by the user, but function types are very simplified in this language, so
    // It ends up being about appropriately heavy for what virtual methods do and how common they are. The way C++ hides them is not prefereable to this syntax, in my opinion.
    printf("%d\n", a@a.virtualMethod(10));

    // Declare a greenApple_instance
    greenApple_instance g;
    
    // Calls greenApple::init with state greenApple_instance
    g@init(100);
    
    // g@print() resolution order:
    // 1. Look for print() in greenApple namespace with state greenApple_instance - not found
    // 2. Delegate via 'inner' - g can substitute as apple_instance
    // 3. Find apple::print with state apple_instance - found!
    g@print();

    // This suffers no loss of precision, because `sub` can be cast to `float(int, float)`
    float curvedShine = sub(g.shine, 0.1f);

    // Every compound statement is conditional, with the format [pre-check for running] {statements} [post-check for repeating].
    // Checks, when omitted, are replaced by the defaults: [true] {statements} [false]
    [curvedShine >= 100] {
        printf("That's a shiny apple you got there\n");
    }
};
